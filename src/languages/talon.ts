import {
  createPatternMatchers,
  argumentMatcher,
  leadingMatcher,
  conditionMatcher,
  trailingMatcher,
  matcher,
  cascadingMatcher,
} from "../util/nodeMatchers";
import { childRangeSelector } from "../util/nodeSelectors";
import { patternFinder } from "../util/nodeFinders";

import { NodeMatcherAlternative } from "../typings/Types";
import { SimpleScopeTypeType } from "../typings/targetDescriptor.types";

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-java/master/src/node-types.json | jq '[.[] | select(.type == "statement" or .type == "declaration") | .subtypes[].type]'
const STATEMENT_TYPES = [
  "expression",
  "command",
  "settings",
  // "block",
];


const nodeMatchers: Partial<
  Record<SimpleScopeTypeType, NodeMatcherAlternative>
> = {
  statement: STATEMENT_TYPES,
  command: "command",
  // NOTE(pcohen): `source_file.context!` allows "take condition" to work everywhere; whereas `context` alone requires a hat.
  condition: "source_file.context!",
  class: "class_declaration",
  className: "class_declaration[name]",
  ifStatement: "if_statement",
  string: "string_literal",
  comment: ["line_comment", "block_comment", "comment"],
  anonymousFunction: "lambda_expression",
  list: "array_initializer",
  functionCall: [
    "expression[0]",
  ],
  functionCallee: "expression[0]",
  collectionKey: [
    "command.rule!",
    "assignment[0]", // TODO(pcohen): ideally match the child by name rather than using an index
    "match[0]", // // TODO(pcohen): ideally match the "key: identifier" rather than using a child index
    "settings", // TODO(pcohen): match the settings(.settings() afterwards
    "include_tag" // TODO(pcohen): match the tag().tag() afterwards
  ],
  name: "command.rule!",
  namedFunction: ["method_declaration", "constructor_declaration"],
  type: trailingMatcher([
    "generic_type.type_arguments.type_identifier",
    "generic_type.type_identifier",
    "type_identifier",
    "local_variable_declaration[type]",
    "array_creation_expression[type]",
    "formal_parameter[type]",
    "method_declaration[type]",
  ]),
  functionName: [
    "method_declaration.identifier!",
    "constructor_declaration.identifier!",
  ],
  value: [
    // TODO(pcohen): match "right"
    "assignment[1]",
    "match[1]", // "key: identifier"
    "block",
  ],
  argumentOrParameter: argumentMatcher("formal_parameters", "argument_list"),
};

export default createPatternMatchers(nodeMatchers);
